#!/usr/bin/env bash
set -euo pipefail

# ------------------------------------------------------------
# monorepo plugin-branch -> main/subdir migrator (same repo)
#
# Layout assumption:
#   - main branch: main
#   - plugin branches: <plugin>/main   (e.g. plugin-a/main)
#   - tags already prefixed: <plugin>/vX.Y.Z  (e.g. plugin-a/v0.1.0)
#
# Actions:
#   - subtree-add each <plugin>/main into plugins/<plugin> on main (NO squash)
#   - retarget existing prefixed tags <plugin>/* to commits on main:
#       plugin-a/v1.2.0 moves to the first main-commit that contains
#       the commit it previously pointed at.
#
# Usage:
#   ./migrate.sh /path/to/repo
#   ./migrate.sh .
# ------------------------------------------------------------

E_USAGE=2
E_NOT_GIT_ROOT=10
E_CD_FAILED=11

log() { printf '%s\n' "$*" >&2; }
die() {
	log "error: $*"
	exit 1
}

usage() {
	cat >&2 <<'EOF'
Usage:
  migrate.sh /path/to/repo

Assumptions:
  - Branches:
      main
      plugin-a/main
      plugin-b/main
  - Tags already exist and are prefixed:
      plugin-a/v0.1.0
      plugin-a/v0.2.0
      plugin-b/v1.0.0

What it does:
  - Checks repo root
  - Checks out main
  - For each <plugin>/main branch:
      * git subtree add into plugins/<plugin> (no squash)
      * force-moves tags plugin/<tag> so they point at the first commit on main
        that contains the commit they currently point to.

After:
  git push origin main
  git push --force origin --tags   (or push per-plugin tags)
EOF
	exit $E_USAGE
}

need_cmd() {
	command -v "$1" >/dev/null 2>&1 || die "missing required command: $1"
}

assert_git_repo_root() {
	local root="${1:-}"
	[ -n "$root" ] || usage
	[ -d "$root" ] || die "not a directory: $root"
	[ -d "$root/.git" ] || die "not a git repo root (no .git dir): $root"
}

cd_repo() {
	cd "$1" || exit $E_CD_FAILED
}

ensure_on_main() {
	git rev-parse --verify main >/dev/null 2>&1 || die "no 'main' branch found"
	git checkout main >/dev/null 2>&1 || die "failed to checkout main"
}

# --- branch discovery --------------------------------------------------------

is_plugin_main_branch_name() {
	local b="$1"
	[[ "$b" == */main && "$b" != "main" ]]
}

list_plugin_main_branches() {
	git for-each-ref --format='%(refname:short)' refs/heads |
		while IFS= read -r b; do
			is_plugin_main_branch_name "$b" || continue
			printf '%s\n' "$b"
		done
}

plugin_name_from_branch() {
	local b="$1"
	printf '%s\n' "${b%/main}"
}

plugin_prefix_dir() {
	local plugin="$1"
	printf '%s\n' "plugins/$plugin"
}

path_exists() {
	[ -e "$1" ]
}

subtree_add_plugin() {
	local plugin="$1"
	local branch="$2"

	local prefix
	prefix="$(plugin_prefix_dir "$plugin")"

	if path_exists "$prefix"; then
		log "    subtree exists, skipping: $prefix"
		return 0
	fi

	git subtree add --prefix="$prefix" "$branch"
}

# --- tag retargeting ---------------------------------------------------------

tag_commit() {
	# Peel annotated tags -> commit
	local tag="$1"
	git rev-parse "$tag^{commit}"
}

list_prefixed_tags_for_plugin() {
	local plugin="$1"
	git tag -l "$plugin/*"
}

first_main_commit_that_contains() {
	# Given a commit C, find the first commit on main that "introduces"
	# that commit into main's history (e.g. the subtree merge/import commit)
	#
	# - If C is directly on main already, return C
	# - Otherwise, return the first commit on main after C becomes reachable
	local c="$1"

	if git merge-base --is-ancestor "$c" main 2>/dev/null; then
		printf '%s\n' "$c"
		return 0
	fi

	# If C is not reachable from main, there is nothing to retarget to
	# (this can happen if subtree import hasn't happened yet)
	return 1
}

retarget_one_tag_to_main() {
	local tag="$1"

	local old_c new_c
	old_c="$(tag_commit "$tag")"

	if ! git merge-base --is-ancestor "$old_c" main 2>/dev/null; then
		log "    skip tag (not reachable from main): $tag"
		return 0
	fi

	# If it's reachable, we can retarget.
	# If you want the *import commit* instead of the original commit ID, use this:
	#
	# new_c = first commit on main along ancestry-path old_c..main
	#
	# If old_c itself is on main, keep it as-is.
	local maybe_import
	maybe_import="$(git rev-list --reverse --ancestry-path "${old_c}..main" | head -n 1 || true)"

	if [ -n "$maybe_import" ]; then
		new_c="$maybe_import"
	else
		new_c="$old_c"
	fi

	if [ "$new_c" = "$old_c" ]; then
		log "    tag ok (already main-reachable): $tag"
		return 0
	fi

	log "    move tag: $tag"
	log "      from: $old_c"
	log "        to: $new_c"

	git tag -fa "$tag" "$new_c" -m "$tag"
}

retarget_plugin_tags_to_main() {
	local plugin="$1"

	local found=0
	while IFS= read -r tag; do
		[ -n "$tag" ] || continue
		found=1
		retarget_one_tag_to_main "$tag"
	done < <(list_prefixed_tags_for_plugin "$plugin")

	if [ "$found" -eq 0 ]; then
		log "    (no tags found for $plugin/*)"
	fi
}

# --- per-plugin migration ----------------------------------------------------

migrate_one_plugin_branch() {
	local branch="$1"
	local plugin
	plugin="$(plugin_name_from_branch "$branch")"

	log "==> migrating: $plugin"
	log "    branch: $branch"

	subtree_add_plugin "$plugin" "$branch"

	# After subtree import, main should contain the old commits,
	# so we can now retarget the plugin's prefixed tags.
	retarget_plugin_tags_to_main "$plugin"

	log ""
}

# --- entrypoint --------------------------------------------------------------

main() {
	local repo_root="${1:-}"
	need_cmd git
	assert_git_repo_root "$repo_root"
	cd_repo "$repo_root"
	ensure_on_main

	local count=0
	while IFS= read -r b; do
		[ -n "$b" ] || continue
		migrate_one_plugin_branch "$b"
		count=$((count + 1))
	done < <(list_plugin_main_branches)

	log "Done. Migrated $count plugin branch(es)."
	log "Next:"
	log "  git push origin main"
	log "  git push --force origin --tags"
	log ""
	log "If others already fetched old tags, they may need:"
	log "  git fetch --tags --force"
}

main "$@"

